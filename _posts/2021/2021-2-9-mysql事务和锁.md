---
layout: post
title: MySQL事务和锁
categories: [mysql]
description: MySQL事务和锁
keywords: MySQL,事务,锁
---

前言：事务的四大特性、事务的状态、四种隔离级别、三大读写问题、两类丢失更新、锁

## 一、事务相关特性

### 1、事务的四大特性

事务包含四大特性，即**原子性（Atomicity）**、**一致性（Consistency）**、**隔离性（Isolation）\**和\**持久性（Durability）**(ACID)。

- 原子性（Atomicity）**原子性是指对数据库的一系列操作，要么全部成功，要么全部失败，不可能出现部分成功的情况**。以转账场景为例，一个账户的余额减少，另一个账户的余额增加，这两个操作一定是同时成功或者同时失败的。
- 一致性（Consistency）**一致性是指数据库的完整性约束没有被破坏，在事务执行前后都是合法的数据状态**。这里的一致可以表示数据库自身的约束没有被破坏，比如某些字段的唯一性约束、字段长度约束等等；还可以表示各种实际场景下的业务约束，比如上面转账操作，一个账户减少的金额和另一个账户增加的金额一定是一样的。
- 隔离性（Isolation）**隔离性指的是多个事务彼此之间是完全隔离、互不干扰的**。隔离性的最终目的也是为了保证一致性。
- 持久性（Durability）**持久性是指只要事务提交成功，那么对数据库做的修改就被永久保存下来了，不可能因为任何原因再回到原来的状态**。

### 2、事务的状态

根据事务所处的不同阶段，事务大致可以分为以下5个状态：

- 活动的（active） 当事务对应的数据库操作正在执行过程中，则该事务处于`活动`状态。
- 部分提交的（partially committed） 当事务中的最后一个操作执行完成，但还未将变更刷新到磁盘时，则该事务处于`部分提交`状态。
- 失败的（failed） 当事务处于`活动`或者`部分提交`状态时，由于某些错误导致事务无法继续执行，则事务处于`失败`状态。
-  中止的（aborted） 当事务处于`失败`状态，且回滚操作执行完毕，数据恢复到事务执行之前的状态时，则该事务处于`中止`状态。
- 提交的（committed） 当事务处于`部分提交`状态，并且将修改过的数据都同步到磁盘之后，此时该事务处于`提交`状态。

![image](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/1739abad476d8622)



### 3、四种隔离级别

 

SQL标准定义了4类隔离级别，包括了一些具体规则，用来限定事务内外的哪些改变是可见的，哪些是不可见的。低级别的隔离级一般支持更高的并发处理，并拥有更低的系统开销。

 

- Read Uncommitted（读取未提交内容）在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。本隔离级别很少用于实际应用，因为它的性能也不比其他级别好多少。读取未提交的数据，也被称之为脏读（Dirty Read）。

 

- Read Committed（读取提交内容）这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了简单的隔离 定义：一个事务只能看见已经提交事务所做的改变。这种隔离级别 也支持所谓的不可重复读（Nonrepeatable Read），因为同一事务的其他实例在该实例处理其间可能会有新的commit，所以同一select可能返回不同结果。

 

- Repeatable Read（可重读） 这是MySQL的默认事务隔离级别，它确保同一事务的多个实例在并发读取数据时，会看到同样的数据行。不过理论上，这会导致另一个棘手的问题：幻读 （Phantom Read）。简单的说，幻读指当用户读取某一范围的数据行时，另一个事务又在该范围内插入了新行，当用户再读取该范围的数据行时，会发现有新的“幻影” 行。InnoDB和Falcon存储引擎通过多版本并发控制（MVCC，Multiversion Concurrency Control）机制解决了该问题。

 

- Serializable（可串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争



### 4、MySQL中的隔离级别及对应的问题

### ![image.png](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/image-1612851191377.png)

## 二、三大读写问题

### 脏读

![image.png](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/image-1612850732139.png)



- **脏读**：读到其他事务未提交的更改数据（update），并进行了操作（最严重） 
- **不可重复读**：读到其他事务已提交的更改的数据（update）   -->行锁
- **幻读**：读到其他事务插入（insert）的数据     -->表锁 
- **第一类丢失更新**：A撤销事务时，覆盖了B事务提交数据 
- **第二类丢失更新**：A事务覆盖B事务提交的数据





### 不可重复读

![image.png](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/image-1612850732138.png)



![image.png](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/image-1612850731783.png)



### 幻读

![image.png](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/image.png)

![image.png](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/image-1612850731997.png)



## 三、两类丢失更新

### 第一类丢失更新



![image.png](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/image-1612850732138.png)

### 第二类丢失更新

![image.png](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/image-1612850731852.png)



## 四、锁

事务并发访问同一数据资源的情况主要就分为`读-读`、`写-写`和`读-写`三种。

1. `读-读`即并发事务同时访问同一行数据记录。由于两个事务都进行只读操作，不会对记录造成任何影响，因此并发读完全允许。
2. `写-写`即并发事务同时修改同一行数据记录。这种情况下可能导致`脏写`问题，这是任何情况下都不允许发生的，因此只能通过`加锁`实现，也就是当一个事务需要对某行记录进行修改时，首先会先给这条记录加锁，如果加锁成功则继续执行，否则就排队等待，事务执行完成或回滚会自动释放锁。
3. `读-写`即一个事务进行读取操作，另一个进行写入操作。这种情况下可能会产生`脏读`、`不可重复读`、`幻读`。最好的方案是**读操作利用多版本并发控制（`MVCC`），写操作进行加锁**。

### 1、锁的粒度

按锁作用的数据范围进行分类的话，锁可以分为`行级锁`和`表级锁`。

-  `行级锁`：作用在数据行上，锁的粒度比较小。
-  `表级锁`：作用在整张数据表上，锁的粒度比较大。

### 2、锁的分类

为了实现`读-读`之间不受影响，并且`写-写`、`读-写`之间能够相互阻塞，`Mysql`使用了`读写锁`的思路进行实现，具体来说就是分为了`共享锁`和`排它锁`：

- `共享锁(Shared Locks)`：简称`S锁`，在事务要读取一条记录时，需要先获取该记录的`S锁`。`S锁`可以在同一时刻被多个事务同时持有。我们可以用`select ...... lock in share mode;`的方式手工加上一把`S锁`
- `排他锁(Exclusive Locks)`：简称`X锁`，在事务要改动一条记录时，需要先获取该记录的`X锁`。`X锁`在同一时刻最多只能被一个事务持有。`X锁`的加锁方式有两种，第一种是自动加锁，在对数据进行增删改的时候，都会默认加上一个`X锁`。还有一种是手工加锁，我们用一个`FOR UPDATE`给一行数据加上一个`X锁`。



还需要注意的一点是，如果一个事务已经持有了某行记录的`S锁`，另一个事务是无法为这行记录加上`X锁`的，反之亦然。



除了`共享锁(Shared Locks)`和`排他锁(Exclusive Locks)`，`Mysql`还有`意向锁(Intention Locks)`。意向锁是由数据库自己维护的，一般来说，当我们给一行数据加上共享锁之前，数据库会自动在这张表上面加一个`意向共享锁(IS锁)`；当我们给一行数据加上排他锁之前，数据库会自动在这张表上面加一个`意向排他锁(IX锁)`。**`意向锁`可以认为是`S锁`和`X锁`在数据表上的标识，通过意向锁可以快速判断表中是否有记录被上锁，从而避免通过遍历的方式来查看表中有没有记录被上锁，提升加锁效率**。例如，我们要加表级别的`X锁`，这时候数据表里面如果存在行级别的`X锁`或者`S锁`的，加锁就会失败，此时直接根据`意向锁`就能知道这张表是否有行级别的`X锁`或者`S锁`。

### 3、InnoDB中的表级锁

`InnoDB`中的表级锁主要包括表级别的`意向共享锁(IS锁)`和`意向排他锁(IX锁)`以及`自增锁(AUTO-INC锁)`。其中`IS锁`和`IX锁`在前面已经介绍过了，这里不再赘述，我们接下来重点了解一下`AUTO-INC锁`。

大家都知道，如果我们给某列字段加了`AUTO_INCREMENT`自增属性，插入的时候不需要为该字段指定值，系统会自动保证递增。系统实现这种自动给`AUTO_INCREMENT`修饰的列递增赋值的原理主要是两个：

-  `AUTO-INC锁`：在执行插入语句的时先加上表级别的`AUTO-INC锁`，插入执行完成后立即释放锁。**如果我们的插入语句在执行前无法确定具体要插入多少条记录，比如`INSERT ... SELECT`这种插入语句，一般采用`AUTO-INC锁`的方式**。
-  `轻量级锁`：在插入语句生成`AUTO_INCREMENT`值时先才获取这个`轻量级锁`，然后在`AUTO_INCREMENT`值生成之后就释放`轻量级锁`。**如果我们的插入语句在执行前就可以确定具体要插入多少条记录，那么一般采用轻量级锁的方式对AUTO_INCREMENT修饰的列进行赋值**。这种方式可以避免锁定表，可以提升插入性能。

> mysql默认根据实际场景自动选择加锁方式，当然也可以通过`innodb_autoinc_lock_mode`强制指定只使用其中一种



### 4、InnoDB中的行级锁

前面说过，通过`MVCC`可以解决`脏读`、`不可重复读`、`幻读`这些读一致性问题，但实际上这只是解决了普通`select`语句的数据读取问题。事务利用`MVCC`进行的读取操作称之为`快照读`，所有普通的`SELECT`语句在`READ COMMITTED`、`REPEATABLE READ`隔离级别下都算是`快照读`。除了`快照读`之外，还有一种是`锁定读`，即在读取的时候给记录加锁，在`锁定读`的情况下依然要解决`脏读`、`不可重复读`、`幻读`的问题。由于都是在记录上加锁，这些锁都属于`行级锁`。

**`InnoDB`的行锁，是通过锁住索引来实现的，如果加锁查询的时候没有使用过索引，会将整个聚簇索引都锁住，相当于锁表了**。根据锁定范围的不同，行锁可以使用`记录锁(Record Locks)`、`间隙锁(Gap Locks)`和`临键锁(Next-Key Locks)`的方式实现。假设现在有一张表`t`，主键是`id`。我们插入了4行数据，主键值分别是 1、4、7、10。接下来我们就以聚簇索引为例，具体介绍三种形式的行锁。

- 记录锁(Record Locks) 所谓记录，就是指聚簇索引中真实存放的数据，比如上面的1、4、7、10都是记录。![image](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/1739abae0b1234ca)

显然，记录锁就是直接锁定某行记录。当我们使用唯一性的索引(包括唯一索引和聚簇索引)进行等值查询且精准匹配到一条记录时，此时就会直接将这条记录锁定。例如`select * from t where id =4 for update;`就会将`id=4`的记录锁定



- 间隙锁(Gap Locks) 间隙指的是两个记录之间逻辑上尚未填入数据的部分，比如上述的(1,4)、(4,7)等。![image](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/1739abac031dfd85)



同理，间隙锁就是锁定某些间隙区间的。当我们使用用等值查询或者范围查询，并且没有命中任何一个`record`，此时就会将对应的间隙区间锁定。例如`select * from t where id =3 for update;`或者`select * from t where id > 1 and id < 4 for update;`就会将(1,4)区间锁定



- 临键锁(Next-Key Locks) 临键指的是间隙加上它右边的记录组成的左开右闭区间。比如上述的(1,4]、(4,7]等。![image](https://raw.githubusercontent.com/taoey/taoey.github.io/master/_pics/2021-2-9-mysql事务和锁.assets/1739abac0420b637)

临键锁就是记录锁(Record Locks)和间隙锁(Gap Locks)的结合，即除了锁住记录本身，还要再锁住索引之间的间隙。当我们使用范围查询，并且命中了部分`record`记录，此时锁住的就是临键区间。注意，临键锁锁住的区间会包含最后一个record的右边的临键区间。例如`select * from t where id > 5 and id <= 7 for update;`会锁住(4,7]、(7,+∞)。mysql默认行锁类型就是`临键锁(Next-Key Locks)`。当使用唯一性索引，等值查询匹配到一条记录的时候，临键锁(Next-Key Locks)会退化成记录锁；没有匹配到任何记录的时候，退化成间隙锁。



`间隙锁(Gap Locks)`和`临键锁(Next-Key Locks)`都是用来解决幻读问题的，在`已提交读（READ COMMITTED）`隔离级别下，`间隙锁(Gap Locks)`和`临键锁(Next-Key Locks)`都会失效！



作者：伍陆七

链接：https://juejin.cn/post/6855129007336521741

来源：掘金

著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。