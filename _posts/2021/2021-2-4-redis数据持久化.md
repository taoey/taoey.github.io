---
layout: post
title: redis 数据持久化
categories: [redis]
description: redis 数据持久化
keywords: redis
---



# 一、RDB快照



## 什么是RDB？

RDB是Redis内存到硬盘的快照。

## RDB三种触发方式？

- save（同步）：不推荐使用，在数据量比较大的时候会造成阻塞 
- **bgsave**（异步 background save） 
- 配置文件自动触发 （不能控制备份频率，不推荐使用）

 

解析：

- save命令会**阻塞当前redis进程**，不推荐使用。如果有老文件则进行替换，save命令的时间复杂度为**O(n)**，在一次备份大约900多兆的内容时，消耗大约8s时间，主进程如果阻塞**8s**，对于高QBS的系统是**致命的**
- bgsave命令会在后台使用linux的**fork****()**开启一个进程进行数据同步，一般认为fork的速度比较快，不会阻塞redis主进程，基本上 Redis内部所有的RDB操作都是采用 bgsave 命令。
- 配置文件自动触发的方式如下：

```
save 900 1
save 300 10
save 60 10000
```



含义为 900秒内有一个变更，或者300秒内有10个变更，或者60秒内有10000个变更时进行数据同步。

bgsave常用配置：

```
# bgsave 写入发生错误时是否停止写入，默认yes
stop-writes-on-bgsave-error yes
# rdb 是否采用压缩模式存储，默认yes
rdbcompression yes
# rdb 校验和检验，默认yes
rdbchecksum yes
# 存储路径，一般选用一个大存储量的位置
dir /bigdiskpath
# 存储文件名称，需要带端口号进行区分
dbfilename dump-${port}.rdb
```

 

其他不可忽视的触发机制：

- 全量复制：主从复制时，主节点会自动生成rdb文件
- debug reload
- shutdown 

 

## 恢复数据

将备份文件 (dump.rdb) 移动到 redis 安装目录并启动服务即可，redis就会自动加载文件数据至内存了。Redis 服务器在载入 RDB 文件期间，会一直处于阻塞状态，直到载入工作完成为止。

 

## RDB 的优势和劣势

①、优势

1.RDB是一个非常紧凑(compact)的文件，它保存了redis 在某个时间点上的数据集。这种文件非常**适合用于进行备份和灾难恢复**。

2.生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。

3.RDB 在恢复**大数据集**时的速度比 AOF 的恢复速度要快。

②、劣势

1、RDB方式数据**没办法做到实时持久化/秒级持久化**。因为bgsave每次运行都要执行fork操作创建子进程，属于**重量级操作**(内存中的数据被克隆了一份，大致2倍的膨胀性需要考虑)，频繁执行成本过高(影响性能)

2、RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题(**版本不兼容**)

3、在一定间隔时间做一次备份，所以如果redis意外down掉的话，就会丢失最后一次快照后的所有修改(**数据有丢失**)

来自 <https://www.cnblogs.com/ysocean/p/9114268.html>



# 二、AOF（append-only-file）



## 什么是AOF？

 

通过保存执行命令来记录数据库状态，使用redis通讯协议(RESP )格式的命令文本存储

 

## AOF配置

![image.png](http://beangogo.cn/assets/images/artcles/2021-2-4-redis数据持久化.assets/1589249473379-e31e14da-dca0-41b6-b087-476b73ede81e.png)

 

①、**appendonly**：默认值为no，也就是说redis 默认使用的是rdb方式持久化，如果想要开启 AOF 持久化方式，需要将 appendonly 修改为 yes。

②、**appendfilename** ：aof文件名，默认是"appendonly.aof"

③、**appendfsync：**aof持久化策略的配置；

no表示不执行fsync，由操作系统保证数据同步到磁盘，速度最快，但是不太安全；

always表示每次写入都执行fsync，以保证数据同步到磁盘，效率很低；

everysec表示每秒执行一次fsync，可能会导致丢失这1s数据。通常选择 everysec ，兼顾安全性和效率。

④、no-appendfsync-on-rewrite：在aof重写或者写入rdb文件的时候，会执行大量IO，此时对于everysec和always的aof模式来说，执行fsync会造成阻塞过长时间，no-appendfsync-on-rewrite字段设置为默认设置为no。如果对延迟要求很高的应用，这个字段可以设置为yes，否则还是设置为no，这样对持久化特性来说这是更安全的选择。  设置为yes表示rewrite期间对新写操作不fsync,暂时存在内存中,等rewrite完成后再写入，默认为no，建议yes。Linux的默认fsync策略是30秒。可能丢失30秒数据。默认值为no。

⑤、auto-aof-rewrite-percentage：默认值为100。aof自动重写配置，当目前aof文件大小超过上一次重写的aof文件大小的百分之多少进行重写，即当aof文件增长到一定大小的时候，Redis能够调用bgrewriteaof对日志文件进行重写。当前AOF文件大小是上次日志重写得到AOF文件大小的二倍（设置为100）时，自动启动新的日志重写过程。

⑥、auto-aof-rewrite-min-size：64mb。设置允许重写的最小aof文件大小，避免了达到约定百分比但尺寸仍然很小的情况还要重写。

⑦、aof-load-truncated：aof文件可能在尾部是不完整的，当redis启动的时候，aof文件的数据被载入内存。重启可能发生在redis所在的主机操作系统宕机后，尤其在ext4文件系统没有加上data=ordered选项，出现这种现象 redis宕机或者异常终止不会造成尾部不完整现象，可以选择让redis退出，或者导入尽可能多的数据。如果选择的是yes，当截断的aof文件被导入的时候，会自动发布一个log给客户端然后load。如果是no，用户必须手动redis-check-aof修复AOF文件才可以。默认值为 yes。

 

## 开启AOF

将 redis.conf 的 appendonly 配置改为 yes 即可。

AOF 保存文件的位置和 RDB 保存文件的位置一样，都是通过 redis.conf 配置文件的 dir 配置：可以通过 config get dir 命令获取保存的路径。

 

## AOF重写

由于AOF持久化是Redis不断将写命令记录到 AOF 文件中，随着Redis不断的进行，AOF 的文件会越来越大，文件越大，占用服务器内存越大以及 AOF 恢复要求时间越长。为了解决这个问题，Redis新增了重写机制，当AOF文件的大小超过所设定的阈值时，Redis就会启动AOF文件的内容压缩，只保留可以恢复数据的最小指令集。可以使用命令 bgrewriteaof 来重写。

 

如果不进行 AOF 文件重写，那么 AOF 文件将保存四条 SADD 命令，如果使用AOF 重写，那么AOF 文件中将只会保留下面一条命令：

```
sadd animals "dog" "tiger" "panda" "lion" "cat"
```

**也就是说 AOF 文件重写并不是对原文件进行重新整理，而是直接读取服务器现有的键值对，然后用一条命令去代替之前记录这个键值对的多条命令，生成一个新的文件后去替换原来的 AOF 文件。**



AOF 文件重写触发机制：通过 redis.conf 配置文件中的 auto-aof-rewrite-percentage：默认值为100，以及auto-aof-rewrite-min-size：64mb 配置，也就是说默认Redis会记录上次重写时的AOF大小，**默认配置是当AOF文件大小是上次rewrite后大小的一倍且文件大于64M时触发。**



这里再提一下，我们知道 Redis 是单线程工作，如果 重写 AOF 需要比较长的时间，那么在重写 AOF 期间，Redis将长时间无法处理其他的命令，这显然是不能忍受的。Redis为了克服这个问题，解决办法是将 AOF 重写程序放到子程序中进行，这样有两个好处：



①、子进程进行 AOF 重写期间，服务器进程（父进程）可以继续处理其他命令。

②、子进程带有父进程的数据副本，使用子进程而不是线程，可以在避免使用锁的情况下，保证数据的安全性。

使用子进程解决了上面的问题，但是新问题也产生了：因为子进程在进行 AOF 重写期间，服务器进程依然在处理其它命令，这新的命令有可能也对数据库进行了修改操作，使得**当前数据库状态和重写后的 AOF 文件状态不一致**。



为了解决这个数据状态不一致的问题，Redis 服务器设置了一个 **AOF 重写缓冲区**，这个缓冲区是在创建子进程后开始使用，当Redis服务器执行一个写命令之后，就会将这个写命令也发送到 AOF 重写缓冲区。当子进程完成 AOF 重写之后，就会给父进程发送一个信号，父进程接收此信号后，就会调用函数将 AOF 重写缓冲区的内容都写到新的 AOF 文件中。

这样将 AOF 重写对服务器造成的影响降到了最低。

 

## AOF的优缺点

优点：

①、AOF 持久化的方法提供了多种的同步频率，即使使用默认的同步频率每秒同步一次，Redis 最多也就丢失 1 秒的数据而已。

②、AOF 文件使用 Redis 命令追加的形式来构造，因此，即使 Redis 只能向 AOF 文件写入命令的片断，使用 redis-check-aof 工具也很容易修正 AOF 文件。

③、AOF 文件的格式可读性较强，这也为使用者提供了更灵活的处理方式。例如，如果我们不小心错用了 FLUSHALL 命令，在重写还没进行时，我们可以手工将最后的 FLUSHALL 命令去掉，然后再使用 AOF 来恢复数据。

缺点：

①、对于具有相同数据的的 Redis，AOF 文件通常会比 RDB 文件体积更大。

②、虽然 AOF 提供了多种同步的频率，默认情况下，每秒同步一次的频率也具有较高的性能。但在 Redis 的负载较高时，RDB 比 AOF 具好更好的性能保证。

③、RDB 使用快照的形式来持久化整个 Redis 数据，而 AOF 只是将每次执行的命令追加到 AOF 文件中，因此从理论上说，RDB 比 AOF 方式更健壮。官方文档也指出，AOF 的确也存在一些 BUG，这些 BUG 在 RDB 没有存在。



那么对于 AOF 和 RDB 两种持久化方式，我们应该如何选择呢？

如果可以忍受一小段时间内数据的丢失，毫无疑问使用 RDB 是最好的，定时生成 RDB 快照（snapshot）非常便于进行数据库备份， 并且 RDB 恢复数据集的速度也要比 AOF 恢复的速度要快，而且使用 RDB 还可以避免 AOF 一些隐藏的 bug；否则就使用 AOF 重写。但是一般情况下建议不要单独使用某一种持久化机制，而是应该两种一起用，在这种情况下,当redis重启的时候会优先载入AOF文件来恢复原始的数据，因为在通常情况下AOF文件保存的数据集要比RDB文件保存的数据集要完整。Redis后期官方可能都有将**两种持久化方式整合**为一种持久化模型。



PS：经过验证，在Redis 5.0.5版本中，如果同时开启RDB和AOF进行持久化，在重启Redis时，**只会加载AOF文件**！！！

 

来自 <https://www.cnblogs.com/ysocean/p/9114267.html> 

 

# 三、Redis持久化的原理及优化

Redis为持久化提供了两种方式：



- RDB：在指定的时间间隔能对你的数据进行快照存储。
- AOF：记录每次对服务器写的操作,当服务器重启的时候会重新执行这些命令来恢复原始的数据。



本文将通过下面内容的介绍，希望能够让大家更全面、清晰的认识这两种持久化方式，同时理解这种保存数据的思路，应用于自己的系统设计中。



- 持久化的配置
- RDB与AOF持久化的工作原理
- 如何从持久化中恢复数据
- 关于性能与实践建议



## 持久化的配置



为了使用持久化的功能，我们需要先知道该如何开启持久化的功能。



### RDB的持久化配置



```
# 时间策略
save 900 1
save 300 10
save 60 10000

# 文件名称
dbfilename dump.rdb

# 文件保存路径
dir /home/work/app/redis/data/

# 如果持久化出错，主进程是否停止写入
stop-writes-on-bgsave-error yes

# 是否压缩
rdbcompression yes

# 导入时是否检查
rdbchecksum yes
```



配置其实非常简单，这里说一下持久化的时间策略具体是什么意思。



- save 900 1 表示900s内如果有1条是写入命令，就触发产生一次快照，可以理解为就进行一次备份
- save 300 10 表示300s内有10条写入，就产生快照



下面的类似，那么为什么需要配置这么多条规则呢？因为Redis每个时段的读写请求肯定不是均衡的，为了平衡性能与数据安全，我们可以自由定制什么情况下触发备份。所以这里就是根据自身Redis写入情况来进行合理配置。



`stop-writes-on-bgsave-error yes` 这个配置也是非常重要的一项配置，这是当备份进程出错时，主进程就停止接受新的写入操作，是为了保护持久化的数据一致性问题。如果自己的业务有完善的监控系统，可以禁止此项配置， 否则请开启。



关于压缩的配置 `rdbcompression yes` ，建议没有必要开启，毕竟Redis本身就属于CPU密集型服务器，再开启压缩会带来更多的CPU消耗，相比硬盘成本，CPU更值钱。



当然如果你想要禁用RDB配置，也是非常容易的，只需要在save的最后一行写上：`save ""`



### AOF的配置



```
# 是否开启aof
appendonly yes

# 文件名称
appendfilename "appendonly.aof"

# 同步方式
appendfsync everysec

# aof重写期间是否同步
no-appendfsync-on-rewrite no

# 重写触发配置
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb

# 加载aof时如果有错如何处理
aof-load-truncated yes

# 文件重写策略
aof-rewrite-incremental-fsync yes
```



复制代码还是重点解释一些关键的配置：



`appendfsync everysec` 它其实有三种模式:



- always：把每个写命令都立即同步到aof，很慢，但是很安全
- everysec：每秒同步一次，是折中方案
- no：redis不处理交给OS来处理，非常快，但是也最不安全



一般情况下都采用 `everysec` 配置，这样可以兼顾速度与安全，最多损失1s的数据。



`aof-load-truncated yes` 如果该配置启用，在加载时发现aof尾部不正确是，会向客户端写入一个log，但是会继续执行，如果设置为 `no` ，发现错误就会停止，必须修复后才能重新加载。



## 工作原理



关于原理部分，我们主要来看RDB与AOF是如何完成持久化的，他们的过程是如何。



在介绍原理之前先说下Redis内部的定时任务机制，定时任务执行的频率可以在配置文件中通过 hz 10 来设置（这个配置表示1s内执行10次，也就是每100ms触发一次定时任务）。该值最大能够设置为：500，但是不建议超过：100，因为值越大说明执行频率越频繁越高，这会带来CPU的更多消耗，从而影响主进程读写性能。



定时任务使用的是Redis自己实现的 TimeEvent，它会定时去调用一些命令完成定时任务，这些任务可能会阻塞主进程导致Redis性能下降。因此我们在配置Redis时，一定要整体考虑一些会触发定时任务的配置，根据实际情况进行调整。



### RDB的原理



在Redis中RDB持久化的触发分为两种：自己手动触发与Redis定时触发。



**针对RDB方式的持久化，手动触发可以使用：**



- save：会阻塞当前Redis服务器，直到持久化完成，线上应该禁止使用。
- **bgsave**：该触发方式会fork一个子进程，由子进程负责持久化过程，因此阻塞只会发生在fork子进程的时候。



**而自动触发的场景主要是有以下几点：**



- 根据我们的 `save m n` 配置规则自动触发；
- 从节点全量复制时，主节点发送`rdb`文件给从节点完成复制操作，主节点会触发 `bgsave`；
- 执行 debug reload 时；
- 执行  shutdown时，如果没有开启aof，也会触发。



由于 save 基本不会被使用到，我们重点看看 bgsave 这个命令是如何完成RDB的持久化的。



![image.png](http://beangogo.cn/assets/images/artcles/2021-2-4-redis数据持久化.assets/1597240739439-3aa8270a-17fa-406b-8974-d14dbe24255e.png)



这里注意的是 fork 操作会阻塞，导致Redis读写性能下降。我们可以控制单个Redis实例的最大内存，来尽可能降低Redis在fork时的事件消耗。以及上面提到的自动触发的频率减少fork次数，或者使用手动触发，根据自己的机制来完成持久化。



### AOF的原理



AOF的整个流程大体来看可以分为两步，一步是命令的实时写入（如果是 `appendfsync everysec` 配置，会有`1s`损耗），第二步是对aof文件的重写。

对于增量追加到文件这一步主要的流程是：`命令写入=>追加到aof_buf =>同步到aof磁盘`。那么这里为什么要先写入buf在同步到磁盘呢？如果实时写入磁盘会带来非常高的磁盘IO，影响整体性能。

aof重写是为了减少aof文件的大小，可以手动或者自动触发，关于自动触发的规则请看上面配置部分。fork的操作也是发生在重写这一步，也是这里会对主进程产生阻塞。

手动触发： `bgrewriteaof`，自动触发 就是根据配置规则来触发，当然自动触发的整体时间还跟Redis的定时任务频率有关系。



下面来看看重写的一个流程图：



![image.png](http://beangogo.cn/assets/images/artcles/2021-2-4-redis数据持久化.assets/1597240753834-f424f6be-c314-4f0b-830d-2bedcfacf5e1.png)



对于上图有四个关键点补充一下：



在重写期间，由于主进程依然在响应命令，为了保证最终备份的完整性；因此它依然会写入旧的AOF file中，如果重写失败，能够保证数据不丢失。

为了把重写期间响应的写入信息也写入到新的文件中，因此也会为子进程保留一个buf，防止新写的file丢失数据。

重写是直接把**当前内存的数据生成对应命令**，并**不需要读取老的AOF文件进行分析、命令合并**。

AOF文件直接采用的文本协议，主要是兼容性好、追加方便、可读性高可认为修改修复。



> 不能是RDB还是AOF都是先写入一个临时文件，然后通过 rename 完成文件的替换工作。



## 从持久化中恢复数据



数据的备份、持久化做完了，我们如何从这些持久化文件中恢复数据呢？如果一台服务器上有既有RDB文件，又有AOF文件，该加载谁呢？

其实想要从这些文件中恢复数据，只需要重新启动Redis即可。我们还是通过图来了解这个流程：



![image.png](http://beangogo.cn/assets/images/artcles/2021-2-4-redis数据持久化.assets/1597240763318-9a4faf0f-dcc8-4150-ad37-9e9b694d5d2f.png)



启动时会先检查AOF文件是否存在，如果不存在就尝试加载RDB。那么为什么会优先加载AOF呢？因为AOF保存的数据更完整，通过上面的分析我们知道AOF基本上最多损失1s的数据。



## 性能与实践



通过上面的分析，我们都知道**RDB的快照、AOF的重写都需要fork，这是一个重量级操作**，**会对Redis造成阻塞**。因此为了不影响Redis主进程响应，我们需要尽可能降低阻塞。



- 降低fork的频率，比如可以手动来触发RDB生成快照、与AOF重写；
- 控制Redis最大使用内存，防止fork耗时过长；
- 使用更牛逼的硬件；
- 合理配置Linux的内存分配策略，**避免因为物理内存不足导致fork失败**。



在线上我们到底该怎么做？我提供一些自己的实践经验。



- 如果Redis中的数据并不是特别敏感或者可以通过其它方式重写生成数据，可以关闭持久化，如果丢失数据可以通过其它途径补回；
- 自己制定策略定期检查Redis的情况，然后可以手动触发备份、重写数据；
- 单机如果部署多个实例，要防止多个机器同时运行持久化、重写操作，防止出现内存、CPU、IO资源竞争，让持久化变为串行；
- 可以加入主从机器，利用一台从机器进行备份处理，其它机器正常响应客户端的命令；
- RDB持久化与AOF持久化可以同时存在，配合使用。



> 作者：大愚Talk
>
> 链接：https://juejin.im/post/5b70dfcf518825610f1f5c16
>
> 来源：掘金
>
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。