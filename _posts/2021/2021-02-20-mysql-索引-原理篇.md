---
layout: post
title: mysql-索引原理篇
categories: [mysql]
description: mysql-索引原理篇
keywords: mysql,查询优化,索引
---



前言：为什么 MySQL 索引要使用 B+树而不是其它树形结构？



## 为什么 MySQL 索引要使用 B+树而不是其它树形结构？



### （1）树的数据量

InnoDB一棵B+树可以存放多少行数据？这个问题的简单回答是：约2千万。

InnoDB存储引擎也有自己的最小储存单元——页（Page），一个页的大小是16K。

innodb的所有数据文件（后缀为ibd的文件），他的大小始终都是16384（16k）的整数倍。

数据表中的数据都是存储在页中的，所以一个页中能存储多少行数据呢？假设一行数据的大小是1k，那么一个页可以存放16行这样的数据。



### （2）为什么二叉树/平衡二叉树不行？

一个二叉查找树是由n个节点随机构成，所以，对于某些情况，二叉查找树会退化成一个有n个节点的线性链。和顺序查找差不多。

显然这个二叉树的查询效率就很低，因此若想最大性能的构造一个二叉查找树，需要这个二叉树是平衡的（这里的平衡从一个显著的特点可以看出这一棵树的高度比上一个输的高度要大，在相同节点的情况下也就是不平衡），从而引出了一个新的定义-平衡二叉树AVL。

AVL树是带有平衡条件的二叉查找树，一般是用平衡因子差值判断是否平衡并通过旋转来实现平衡，左右子树树高不超过1，和红黑树相比，它是严格的平衡二叉树，平衡条件必须满足（所有节点的左右子树高度差不超过1）。

不管我们是执行插入还是删除操作，只要不满足上面的条件，就要通过旋转来保持平衡，而**旋转是非常耗时**的，由此我们可以知道**AVL树适合用于插入删除次数比较少，但查找多**的情况，以避免二叉树的旋转



### （3）为什么B树不行？

因为B树不管叶子节点还是非叶子节点，都会保存数据，这样导致在**非叶子节点中能保存的指针数量变少**（有些资料也称为**扇出**）。指针少的情况下要保存大量数据，**只能增加树的高度，导致IO操作变多**，查询性能变低；



### （4）为什么B+树行？

1、 B+树的**磁盘读写代价更低**：B+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对B树更小，如果把所有同一内部节点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多，一次性读入内存的需要查找的关键字也就越多，相对IO读写次数就降低了。

2、B+树的**查询效率更加稳定**：由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3、由于B+树的**数据都存储在叶子结点中**，分支结点均为索引，方便扫库，只需要扫一遍叶子结点即可，但是B树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以B+树更加适合在区间查询的情况，所以通常B+树用于数据库索引。